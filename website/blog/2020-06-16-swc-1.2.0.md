---
title: "swc v1.2.0: Yet another asset bundler"
author: DongYoon Kang
authorURL: "http://github.com/kdy1"
authorFBID: 100024888122318
---

## Features

### Compact output

Just like rollup, spack emits compact output.

`a.js`:

```js
console.log("loading A");
export function a() {
  console.log("use!");
}
```

`lib.js`

```js
import { a } from "./a";
a();
```

becomes

```js
console.log("loading A");
function a() {
  console.log("use!");
}
a();
```

Because `swc` was designed with this type of merging in mind, files are merged without any problems even if the same name exists in multiple files.

### Tree shaking

Just like other modern bundlers, `spack` can remove unused exports.

### Import deglobbing

To aid tree shaking, `spack` deglobs import if possible.

```js
import * as lib from "lib";
lib.foo();
```

behaves exactly same as

```js
import { foo } from "lib";
foo();
```

Note that all side effects are preserved.

### Optimizations

Currently `swc` does

- ilining
- constant propagation
- dead code elimiation

Actually the tree shaking described above is implemented using dead code elimination pass.

### High performance

As always, performance is first-class citizen. It's faster than other bundlers even though

### swc integration

You can use es2018, module import / export-s and some staged proposals without installing any additional dependency.

### Multiple entries

### Built-in chunking

### Type annotation for config file

`spack` provides type annotations for the config. You can get assists from ide just by wrappping your configuration object with `config`. Note that it's just an identity function with type annoatations.

`spack.config.js`:

```js
const { config } = require("@swc/core/spack");

module.exports = config({
  entry: {
    web: __dirname + "/src/index.ts",
  },
  output: {
    path: __dirname + "/lib",
  },
  module: {},
});
```

### Fine config

If you want to bundle everything in each bundle, you can provide an array of configurations.

e.g.

```js
const { config } = require("@swc/core/spack");

module.exports = config([
  {
    entry: {
      desktop: __dirname + "/src/desktop.ts",
    },
    output: {
      path: __dirname + "/lib",
    },
    module: {},
  },
  {
    entry: {
      mobile: __dirname + "/src/mobile.ts",
    },
    output: {
      path: __dirname + "/lib",
    },
    module: {},
  },
]);
```

results in two full bundle (`desktop.js`, `mobile.js`), while

```js
const { config } = require("@swc/core/spack");

module.exports = config({
  entry: {
    desktop: __dirname + "/src/desktop.ts",
    mobile: __dirname + "/src/mobile.ts",
  },
  output: {
    path: __dirname + "/lib",
  },
  module: {},
});
```

results in chunking. In this case, the output will be `desktop.js`, `mobile.js`, `common-[hash].js`, assuming there's a common dependency.

## Roadmap

### webpack-compatible plugin api

`spack` will provide webpack-compatible apis, so you will be able to use webpack loaders and plugins without changing the plugin. All you need to do will be changing imports and file name.

I couldn't implement this because currently there's no way to wait for a promise to be resolved from rust code.
I'll implement this feature as soon as possible after [neon#73](https://github.com/neon-bindings/neon/issues/73) or [node-bidgen#37](https://github.com/infinyon/node-bindgen/issues/37) is fixed. (I'm open to switchig from neon to node-bindgen).

### dynamic imports (and code splitting)

### require support

This feature is quite simple to implement.

### minification ([#826](https://github.com/swc-project/swc/pull/826))

I think this function is one of the key functions for a bundler.
